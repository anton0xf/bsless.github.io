---
layout: post
title: "Fast and Elegant Clojure"
subtitle: "Idiomatic Clojure without sacrificing performance"
permalink: /:title/
tags: [clojure, "idiomatic" ,"performance"]
categories: [clojure, "idiomatic" ,"performance"]
---

<p>
A couple of weeks ago a <a href="https://news.ycombinator.com/item?id=28723447">comment on HN</a> caught my eye:
</p>

<blockquote>
<p>
I write Clojure for food, and Common Lisp for fun. One reason for the
latter is CL's speed &#x2013; awhile back I compared a bit of (non-optimized)
Clojure code I wrote for a blog post with a rough equivalent in CL, and
was stunned that the Common Lisp code ran about 10x faster. This made me
curious as to how fast it could be made if I really tried, and was able
to get nearly 30x more<a href="http://johnj.com/from-elegance-to-speed.html">1</a> by optimizing it.
</p>

<p>
Clojure is definitely fast enough for everything I've done
professionally for six years. But Common Lisp, while having plenty of
rough edges, intrigues on the basis of performance alone. (This is on
SBCL &#x2013; I have yet to play with a commercial implementation.)
</p>
</blockquote>

<p>
And I took that personally.
</p>

<p>
<a href="https://noahtheduke.github.io/posts/2021-10-02-from-elegance-to-speed-with-clojure/">I wasn't the only one, either</a>.
</p>

<div id="outline-container-org73465a9" class="outline-2">
<h2 id="org73465a9">The Premise</h2>
<div class="outline-text-2" id="text-org73465a9">
</div>
<div id="outline-container-org7a75755" class="outline-3">
<h3 id="org7a75755">Non Optimized Clojure Is Slow</h3>
<div class="outline-text-3" id="text-org7a75755">
<p>
This premise hides two assumptions:
</p>
<ul class="org-ul">
<li>Idiomatic Clojure is slow</li>
<li>Optimized Clojure is non idiomatic</li>
</ul>

<p>
Let us examine these assumptions by looking at the original implementation:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">smt-8</span> <span style="color: #6c3163;">[</span>times<span style="color: #6c3163;">]</span>
  <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">-&gt;&gt;</span> times
       <span style="color: #2d9574;">(</span>partition <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
       <span style="color: #2d9574;">(</span>map <span style="color: #67b11d;">(</span>juxt identity
                  <span style="color: #b1951d;">(</span>comp <span style="color: #3a81c3;">(</span>partial apply -<span style="color: #3a81c3;">)</span>
                        <span style="color: #3a81c3;">(</span>juxt last first<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
       <span style="color: #2d9574;">(</span>filter <span style="color: #67b11d;">(</span>comp <span style="color: #b1951d;">(</span>partial &gt; <span style="color: #4e3163;">1000</span><span style="color: #b1951d;">)</span> second<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
There is absolutely nothing wrong with it. It's correct and
demonstrates a good use of composition.
</p>

<p>
It is, however, far from optimal, even in terms of Clojure's performance.
</p>

<p>
As we'll see further on, by refactoring this function our code will be
both more idiomatic and perform better.
</p>
</div>
</div>
</div>

<div id="outline-container-orgf4d7e28" class="outline-2">
<h2 id="orgf4d7e28">Baseline</h2>
<div class="outline-text-2" id="text-orgf4d7e28">
<p>
Setting up some test data, we can get a baseline measurement:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span>require '<span style="color: #6c3163;">[</span>criterium.core <span style="color: #4e3163;">:as</span> cc<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">times-v</span> <span style="color: #6c3163;">(</span>into <span style="color: #2d9574;">[]</span> <span style="color: #2d9574;">(</span>take <span style="color: #4e3163;">1e6</span><span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>iterate #<span style="color: #67b11d;">(</span>+ <span style="color: #715ab1;">%</span> <span style="color: #b1951d;">(</span>rand-int <span style="color: #4e3163;">1000</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span> <span style="color: #4e3163;">0</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>smt-8 times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 6 in 6 samples of 1 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 1.159347 sec</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 17.835002 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 1.143263 sec ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 1.186615 sec (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
It's important to note an initial oversight by the author, who
benchmarked his code against a lazily generated sequence.
</p>

<p>
I gave the code a head start by realizing it in a vector.
</p>

<p>
Throughout this post I benchmark with only one input collection size.
You can either believe me that performance scales linearly for all
implementations, or check for yourselves.
</p>
</div>
</div>

<div id="outline-container-org2e4f049" class="outline-2">
<h2 id="org2e4f049">First Step - the missing transducer</h2>
<div class="outline-text-2" id="text-org2e4f049">
<p>
This use case is perfect for transducers. They were written exactly
for a series of sequence transformations:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">-&gt;&gt;</span> xs
     <span style="color: #6c3163;">(</span>map f<span style="color: #6c3163;">)</span>
     <span style="color: #6c3163;">(</span>filter g<span style="color: #6c3163;">)</span>
     <span style="color: #6c3163;">(</span>map h<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">is equivalent to =&gt;</span>
<span style="color: #3a81c3;">(</span>sequence
 <span style="color: #6c3163;">(</span>comp
  <span style="color: #2d9574;">(</span>map f<span style="color: #2d9574;">)</span>
  <span style="color: #2d9574;">(</span>filter g<span style="color: #2d9574;">)</span>
  <span style="color: #2d9574;">(</span>map h<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
 xs<span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
With the added bonus of removing intermediary allocations. That's
pretty neat. The only problem is we're missing a crucial component.
There is no transducer equivalent to <code>(partition n step coll)</code>.
</p>

<p>
Are we doomed? Not quite.
</p>

<p>
There is a close transducer, <code>partition-all</code>, which has no step
arity. Let's look at how it's implemented:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">partition-all</span>
  <span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> n<span style="color: #2d9574;">]</span>
   <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #67b11d;">[</span>rf<span style="color: #67b11d;">]</span>
     <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #b1951d;">[</span>a <span style="color: #3a81c3;">(</span>java.util.ArrayList. n<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">]</span>
       <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[]</span> <span style="color: #6c3163;">(</span>rf<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result<span style="color: #6c3163;">]</span>
          <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #2d9574;">[</span>result <span style="color: #887070;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>.isEmpty a<span style="color: #3a81c3;">)</span>
                         result
                         <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #6c3163;">[</span>v <span style="color: #2d9574;">(</span>vec <span style="color: #67b11d;">(</span>.toArray a<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">]</span>
                           <span style="color: #2aa1ae; background-color: #ecf3ec;">;;</span><span style="color: #2aa1ae; background-color: #ecf3ec;">clear first!</span>
                           <span style="color: #6c3163;">(</span>.clear a<span style="color: #6c3163;">)</span>
                           <span style="color: #6c3163;">(</span>unreduced <span style="color: #2d9574;">(</span>rf result v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #887070;">)</span><span style="color: #2d9574;">]</span>
            <span style="color: #2d9574;">(</span>rf result<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result input<span style="color: #6c3163;">]</span>
          <span style="color: #6c3163;">(</span>.add a input<span style="color: #6c3163;">)</span>
          <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= n <span style="color: #887070;">(</span>.size a<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #887070;">[</span>v <span style="color: #3a81c3;">(</span>vec <span style="color: #6c3163;">(</span>.toArray a<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #887070;">]</span>
              <span style="color: #887070;">(</span>.clear a<span style="color: #887070;">)</span>
              <span style="color: #887070;">(</span>rf result v<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            result<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
If we wanted a sliding window, all we have to do was replace the
ArrayList with a Queue!
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">sliding</span>
  <span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> n<span style="color: #2d9574;">]</span>
   <span style="color: #2d9574;">(</span>sliding n <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span>
  <span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> n <span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> step<span style="color: #2d9574;">]</span>
   <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #67b11d;">[</span>rf<span style="color: #67b11d;">]</span>
     <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #b1951d;">[</span>a <span style="color: #3a81c3;">(</span>java.util.ArrayDeque. n<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">]</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Queue here</span>
       <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[]</span> <span style="color: #6c3163;">(</span>rf<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result<span style="color: #6c3163;">]</span> <span style="color: #6c3163;">(</span>rf result<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">don't need leftovers</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result input<span style="color: #6c3163;">]</span>
          <span style="color: #6c3163;">(</span>.add a input<span style="color: #6c3163;">)</span>
          <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= n <span style="color: #887070;">(</span>.size a<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #887070;">[</span>v <span style="color: #3a81c3;">(</span>vec <span style="color: #6c3163;">(</span>.toArray a<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #887070;">]</span>
              <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Remove `</span><span style="color: #4e3163; background-color: #ecf3ec;">step</span><span style="color: #2aa1ae; background-color: #ecf3ec;">` elements instead of clear</span>
              <span style="color: #887070;">(</span><span style="color: #3a81c3; font-weight: bold;">dotimes</span> <span style="color: #3a81c3;">[</span>_ step<span style="color: #3a81c3;">]</span> <span style="color: #3a81c3;">(</span>.removeFirst a<span style="color: #3a81c3;">)</span><span style="color: #887070;">)</span>
              <span style="color: #887070;">(</span>rf result v<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            result<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
Let's convinces ourselves it works:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span>sequence <span style="color: #6c3163;">(</span>sliding <span style="color: #4e3163;">3</span> <span style="color: #4e3163;">1</span><span style="color: #6c3163;">)</span> '<span style="color: #6c3163;">[</span>a b c d e<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span><span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; ([a b c] [b c d] [c d e])</span>
</pre>
</div>

<p>
Now we can define an equivalent transducer:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">baseline-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>map <span style="color: #67b11d;">(</span>juxt identity
              <span style="color: #b1951d;">(</span>comp <span style="color: #3a81c3;">(</span>partial apply -<span style="color: #3a81c3;">)</span>
                    <span style="color: #3a81c3;">(</span>juxt last first<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>filter <span style="color: #67b11d;">(</span>comp <span style="color: #b1951d;">(</span>partial &gt; <span style="color: #4e3163;">1000</span><span style="color: #b1951d;">)</span> second<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence baseline-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 6 in 6 samples of 1 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 462.921956 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 20.213288 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 453.931650 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 497.963799 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.079753 ns</span>
</pre>
</div>

<p>
And we're already ~2.5x faster
</p>
</div>
</div>

<div id="outline-container-org1b51859" class="outline-2">
<h2 id="org1b51859">De-composing</h2>
<div class="outline-text-2" id="text-org1b51859">
<p>
How much overhead is there to all this functional composition? Let's
find out:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">decomposed-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>map <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span>v<span style="color: #b1951d;">]</span> <span style="color: #b1951d;">[</span>v <span style="color: #3a81c3;">(</span>- <span style="color: #6c3163;">(</span>last v<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">(</span>first v<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">]</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>filter <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span><span style="color: #3a81c3;">[</span>_ t<span style="color: #3a81c3;">]</span><span style="color: #b1951d;">]</span> <span style="color: #b1951d;">(</span>&gt; <span style="color: #4e3163;">1000</span> t<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span>= <span style="color: #6c3163;">(</span>sequence decomposed-xf times-v<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">(</span>smt-8 times-v<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>
<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence decomposed-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 6 in 6 samples of 1 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 366.650954 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 2.112047 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 365.042052 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 370.254096 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
25% faster? How come? The culprit is mainly <code>apply</code>. <code>juxt</code> returns a
vector of two elements and apply takes it back apart, one element at a
time. Iteration has its price.
</p>
</div>
</div>

<div id="outline-container-org0b4e10a" class="outline-2">
<h2 id="org0b4e10a">Faster vector operations</h2>
<div class="outline-text-2" id="text-org0b4e10a">
<p>
<code>first</code> and <code>last</code> will work on pretty much everything, including Java
arrays. It does not mean, however, it is a good idea.
Vectors can be accessed faster using indexed access.
</p>

<p>
Since our last vector won't have 8 elements, we can generically get the
last element by using peek. Looking at its docstring:
</p>
<blockquote>
<p>
For a list or queue, same as first, for a vector, same as, but much
more efficient than, last. If the collection is empty, returns nil.
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">vector-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>map <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span>v<span style="color: #b1951d;">]</span> <span style="color: #b1951d;">[</span>v <span style="color: #3a81c3;">(</span>- <span style="color: #6c3163;">(</span>peek v<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">(</span>nth v <span style="color: #4e3163;">0</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">]</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>filter <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span><span style="color: #3a81c3;">[</span>_ t<span style="color: #3a81c3;">]</span><span style="color: #b1951d;">]</span> <span style="color: #b1951d;">(</span>&gt; <span style="color: #4e3163;">1000</span> t<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span>= <span style="color: #6c3163;">(</span>sequence decomposed-xf times-v<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">(</span>sequence vector-xf times-v<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>
<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence vector-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 12 in 6 samples of 2 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 88.566441 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 350.326432 &#181;s</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 88.235538 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 89.062221 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
Now we're beginning to see some dramatic improvements. It is mostly due
to the overhead of <code>last</code>, which <b>always</b> iterates over the input
collection, and does not even take the most efficient code paths to do
so.
</p>
</div>
</div>

<div id="outline-container-org17c5fb0" class="outline-2">
<h2 id="org17c5fb0">Something between map and filter</h2>
<div class="outline-text-2" id="text-org17c5fb0">
<p>
Ideally, we would have liked to only allocate the vector in the <code>map</code>
transducer if the condition in <code>filter</code> is satisfied. Can we? Enter <code>keep</code>:
</p>

<blockquote>
<p>
Returns a lazy sequence of the non-nil results of (f item). Note,
this means false return values will be included.  f must be free of
side-effects.  Returns a transducer when no collection is provided.
</p>
</blockquote>

<p>
Turns out, that's exactly what we needed. We can then discard the
difference calculation and not allocate another vector:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">keep-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>keep <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span>v<span style="color: #b1951d;">]</span>
           <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">when</span> <span style="color: #3a81c3;">(</span>&gt; <span style="color: #4e3163;">1000</span> <span style="color: #6c3163;">(</span>- <span style="color: #2d9574;">(</span>peek v<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>nth v <span style="color: #4e3163;">0</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
             v<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span>= <span style="color: #6c3163;">(</span>sequence keep-xf times-v<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">(</span>map first <span style="color: #2d9574;">(</span>sequence vector-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>
<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence keep-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 12 in 6 samples of 2 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 80.411626 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 1.211228 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 79.822031 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 82.508332 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
Slightly faster. Since we know the inputs will always be <code>long</code>, we can use unchecked maths:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">unchecked-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>keep <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span>v<span style="color: #b1951d;">]</span>
           <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">when</span> <span style="color: #3a81c3;">(</span>&gt; <span style="color: #4e3163;">1000</span> <span style="color: #6c3163;">(</span>unchecked-subtract <span style="color: #2d9574;">(</span>long <span style="color: #887070;">(</span>peek v<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>long <span style="color: #887070;">(</span>nth v <span style="color: #4e3163;">0</span><span style="color: #887070;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
             v<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence unchecked-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 12 in 6 samples of 2 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 66.642476 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 356.808224 &#181;s</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 66.323382 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 67.047693 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
Another 20%!
</p>

<p>
Up to this point, we can pat ourselves on the back and say our code is
still idiomatic on one hand, but performs way better on the other. About
15x faster, while non optimized CL was only 10x faster.
</p>

<p>
As an added bonus, this looks pretty idiomatic.
</p>
</div>
</div>

<div id="outline-container-org92b1527" class="outline-2">
<h2 id="org92b1527">Aside: wasn't the sliding transducer an optimization?</h2>
<div class="outline-text-2" id="text-org92b1527">
<p>
You could argue that it is. Or that it's a missing piece. It should
probably live in a library. I also don't think it was complicated to
derive, although transducers might be unwieldy for beginners.
</p>

<p>
Compare the initial snippet with the final version:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">smt-8</span> <span style="color: #6c3163;">[</span>times<span style="color: #6c3163;">]</span>
  <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">-&gt;&gt;</span> times
       <span style="color: #2d9574;">(</span>partition <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
       <span style="color: #2d9574;">(</span>map <span style="color: #67b11d;">(</span>juxt identity
                  <span style="color: #b1951d;">(</span>comp <span style="color: #3a81c3;">(</span>partial apply -<span style="color: #3a81c3;">)</span>
                        <span style="color: #3a81c3;">(</span>juxt last first<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>
       <span style="color: #2d9574;">(</span>filter <span style="color: #67b11d;">(</span>comp <span style="color: #b1951d;">(</span>partial &gt; <span style="color: #4e3163;">1000</span><span style="color: #b1951d;">)</span> second<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">keep-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>keep <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span>v<span style="color: #b1951d;">]</span>
           <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">when</span> <span style="color: #3a81c3;">(</span>&gt; <span style="color: #4e3163;">1000</span> <span style="color: #6c3163;">(</span>- <span style="color: #2d9574;">(</span>peek v<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">(</span>nth v <span style="color: #4e3163;">0</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
             v<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
I would consider the latter way more idiomatic <i>and</i> concise.
</p>
</div>
</div>

<div id="outline-container-org01e4f54" class="outline-2">
<h2 id="org01e4f54">Slightly less idiomatic</h2>
<div class="outline-text-2" id="text-org01e4f54">
<p>
Do we have to get the results back as vectors? If we relax this
requirement, we can skip over wrapping the results in the sliding
transducer in a vector:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">sliding-array</span>
  <span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> n <span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">long</span> step<span style="color: #2d9574;">]</span>
   <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #67b11d;">[</span>rf<span style="color: #67b11d;">]</span>
     <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #b1951d;">[</span>a <span style="color: #3a81c3;">(</span>java.util.ArrayDeque. n<span style="color: #3a81c3;">)</span><span style="color: #b1951d;">]</span>
       <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[]</span> <span style="color: #6c3163;">(</span>rf<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result<span style="color: #6c3163;">]</span> <span style="color: #6c3163;">(</span>rf result<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
         <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>result input<span style="color: #6c3163;">]</span>
          <span style="color: #6c3163;">(</span>.add a input<span style="color: #6c3163;">)</span>
          <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>= n <span style="color: #887070;">(</span>.size a<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #887070;">[</span>v <span style="color: #3a81c3;">(</span>.toArray a<span style="color: #3a81c3;">)</span><span style="color: #887070;">]</span>
              <span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Remove `</span><span style="color: #4e3163; background-color: #ecf3ec;">step</span><span style="color: #2aa1ae; background-color: #ecf3ec;">` elements instead of clear</span>
              <span style="color: #887070;">(</span><span style="color: #3a81c3; font-weight: bold;">dotimes</span> <span style="color: #3a81c3;">[</span>_ step<span style="color: #3a81c3;">]</span> <span style="color: #3a81c3;">(</span>.removeFirst a<span style="color: #3a81c3;">)</span><span style="color: #887070;">)</span>
              <span style="color: #887070;">(</span>rf result v<span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
            result<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div>

<p>
Then, modify the argument to <code>keep</code> to take an array:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #715ab1;">array-xf</span>
  <span style="color: #6c3163;">(</span>comp
   <span style="color: #2d9574;">(</span>sliding-array <span style="color: #4e3163;">8</span> <span style="color: #4e3163;">1</span><span style="color: #2d9574;">)</span>
   <span style="color: #2d9574;">(</span>keep <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">fn</span> <span style="color: #b1951d;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">objects</span> arr<span style="color: #b1951d;">]</span>
           <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">when</span> <span style="color: #3a81c3;">(</span>&gt; <span style="color: #4e3163;">1000</span> <span style="color: #6c3163;">(</span>unchecked-subtract
                          <span style="color: #2d9574;">(</span>long <span style="color: #887070;">(</span>aget arr <span style="color: #4e3163;">7</span><span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
                          <span style="color: #2d9574;">(</span>long <span style="color: #887070;">(</span>aget arr <span style="color: #4e3163;">0</span><span style="color: #887070;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
             arr<span style="color: #b1951d;">)</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">doall</span> <span style="color: #2d9574;">(</span>sequence array-xf times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 30 in 6 samples of 5 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 23.127029 ms</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 192.325091 &#181;s</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 22.890029 ms ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 23.325306 ms (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
Another ~3x speedup, new 50x times faster than the original, without
going crazy with interop, optimization or some unrolling.
</p>
</div>
</div>

<div id="outline-container-orgb051dde" class="outline-2">
<h2 id="orgb051dde">But can we go faster?</h2>
<div class="outline-text-2" id="text-orgb051dde">
<p>
Let us put aside our requirement for idiomatic Clojure. Let's settle on readable.
</p>

<p>
By converting the input to an array, we can work directly with indices
and built up the results collection. We'll also take advantage of the
fact that linked lists are pretty fast to allocate, so build those
instead of a vector or set:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">defn</span> <span style="color: #6c3163; font-weight: bold;">unrolled</span>
  <span style="color: #6c3163;">[</span><span style="color: #655370; background-color: #fbf8ef;">^</span><span style="color: #ba2f59; font-weight: bold;">longs</span> arr<span style="color: #6c3163;">]</span>
  <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #2d9574;">[</span>l <span style="color: #67b11d;">(</span>unchecked-subtract <span style="color: #b1951d;">(</span>alength arr<span style="color: #b1951d;">)</span> <span style="color: #4e3163;">7</span><span style="color: #67b11d;">)</span><span style="color: #2d9574;">]</span>
    <span style="color: #2d9574;">(</span><span style="color: #3a81c3; font-weight: bold;">loop</span> <span style="color: #67b11d;">[</span>idx <span style="color: #b1951d;">(</span>int <span style="color: #4e3163;">0</span><span style="color: #b1951d;">)</span> agg <span style="color: #b1951d;">()</span><span style="color: #67b11d;">]</span>
      <span style="color: #67b11d;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #b1951d;">(</span>&lt; idx l<span style="color: #b1951d;">)</span>
        <span style="color: #b1951d;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span>idx <span style="color: #6c3163;">(</span>int idx<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
          <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">recur</span>
           <span style="color: #6c3163;">(</span>unchecked-inc-int idx<span style="color: #6c3163;">)</span>
           <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>&gt; <span style="color: #4e3163;">1000</span> <span style="color: #887070;">(</span>unchecked-subtract <span style="color: #3a81c3;">(</span>aget arr <span style="color: #6c3163;">(</span>unchecked-add-int idx <span style="color: #4e3163;">7</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">(</span>aget arr idx<span style="color: #3a81c3;">)</span><span style="color: #887070;">)</span><span style="color: #2d9574;">)</span>
             <span style="color: #2d9574;">(</span>.cons agg idx<span style="color: #2d9574;">)</span>
             agg<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span><span style="color: #b1951d;">)</span>
        agg<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">set!</span> <span style="color: #3a81c3;">*unchecked-math*</span> <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #6c3163;">[</span>arr <span style="color: #2d9574;">(</span>long-array times-v<span style="color: #2d9574;">)</span><span style="color: #6c3163;">]</span>
  <span style="color: #6c3163;">(</span><span style="color: #ba2f59; font-weight: bold;">cc</span>/quick-bench <span style="color: #2d9574;">(</span>unrolled arr<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;; </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Evaluation count : 912 in 6 samples of 152 calls.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;              </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time mean : 655.284194 &#181;s</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time std-deviation : 2.846323 &#181;s</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time lower quantile : 651.150750 &#181;s ( 2.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Execution time upper quantile : 658.353038 &#181;s (97.5%)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">;;                    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Overhead used : 2.066166 ns</span>
</pre>
</div>

<p>
Another 35x speedup!
</p>

<p>
This implementation is very different. It deals with a concrete array
instead of a sequence abstraction, and explicitly builds up the result.
It allocates a lot less and sequentially accesses memory.
</p>

<p>
It's more similar to a solution in Java then Clojure, but it's pretty
readable. It might even be more readable to programmers unfamiliar with
Clojure.
</p>

<p>
I feel pretty comfortable saying that Clojure is not slow. I did not
even have to disassemble it, tweak anything, or write complicated code.
</p>

<p>
The gains here are a result of a few actions:
</p>
<ul class="org-ul">
<li>cutting down on allocation
<ul class="org-ul">
<li>partition -&gt; sliding</li>
<li>lazy sequences -&gt; transducers</li>
<li>map / filter -&gt; keep</li>
</ul></li>
<li>cutting down on iteration
<ul class="org-ul">
<li>last -&gt; peek</li>
<li>juxt / apply -&gt; direct function calls</li>
</ul></li>
<li>Using primitives instead of collections
<ul class="org-ul">
<li>Vectors -&gt; arrays make for faster access</li>
<li>Working directly with arrays and contiguous memory access</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgebdbd09" class="outline-2">
<h2 id="orgebdbd09">Final Scores</h2>
<div class="outline-text-2" id="text-orgebdbd09">
<p>
Let's take a moment to reflect on how far we've gone
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">step</td>
<td class="org-right">time (ms)</td>
<td class="org-right">improvement</td>
<td class="org-right">relative</td>
</tr>

<tr>
<td class="org-left">baseline</td>
<td class="org-right">1159</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">xf</td>
<td class="org-right">463</td>
<td class="org-right">2.5032397</td>
<td class="org-right">2.5032397</td>
</tr>

<tr>
<td class="org-left">decomposed</td>
<td class="org-right">366</td>
<td class="org-right">3.1666667</td>
<td class="org-right">1.2650273</td>
</tr>

<tr>
<td class="org-left">vector</td>
<td class="org-right">88</td>
<td class="org-right">13.170455</td>
<td class="org-right">4.1590909</td>
</tr>

<tr>
<td class="org-left">keep</td>
<td class="org-right">80</td>
<td class="org-right">14.4875</td>
<td class="org-right">1.1</td>
</tr>

<tr>
<td class="org-left">unchecked</td>
<td class="org-right">66</td>
<td class="org-right">17.560606</td>
<td class="org-right">1.2121212</td>
</tr>

<tr>
<td class="org-left">array</td>
<td class="org-right">23</td>
<td class="org-right">50.391304</td>
<td class="org-right">2.8695652</td>
</tr>

<tr>
<td class="org-left">iteration</td>
<td class="org-right">0.655</td>
<td class="org-right">1769.4656</td>
<td class="org-right">35.114504</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-orgc7e8ef6" class="outline-2">
<h2 id="orgc7e8ef6">Should you try this at home?</h2>
<div class="outline-text-2" id="text-orgc7e8ef6">
<blockquote>
<p>
premature optimization is the root of all evil. Yet we should not pass
up our opportunities in that critical 3% &#x2013; Donald Knuth
</p>
</blockquote>

<p>
The answer as always is "it depends"; Things like using <code>nth</code>, <code>peek</code>
and <code>pop</code> instead of <code>first</code> and <code>last</code>, using transducers instead of
lazy sequences, and familiarity with Clojure's core (e.g. <code>keep</code>) are
good and will probably produce more idiomatic code. They can be embraced
as habits.
</p>

<p>
On the other hand, things like writing your own transducers, especially
ones built with Java interop, and working directly with arrays should be
reserved for special circumstances.
</p>

<p>
Do profile your code first, understand the problems and use cases,
<i>then</i> optimize to your heart's content, secure in the knowledge that if
you need to, Clojure can probably get there.
</p>


<p>
Happy hacking
</p>
</div>
</div>
